
import os
import json
import time
from datetime import datetime
from cvebot.CVEScout import CVEScout
from pydiscourse import DiscourseClient

def timestamp():
    now = datetime.now()
    return now.strftime('%Y-%m-%d')

# Uses dicourse API wrapper pydiscourse and CVE sources
# to post CVEs on discourse daily
class DiscourseCVEBot:

    def __init__(self, url, username, api_key):
        self.url = url
        self.user = username
        self.api_key = api_key

        self.client = DiscourseClient(
            self.url,
            api_username = self.user,
            api_key = self.api_key
        )
    

    # creates a readable paragraph from a dictionary
    # this function will take in CVE dictionary from database API
    # and return a string format with filtered results suitible for blog post
    # append all post formatting changed here!
    # 
    # ARGS: Can be passed a single cve or list of cves.
    def readable(self, elements):
        readable_text = ''
        
        # allowed for a list or dict
        elements = list(elements)

        for element in elements:
            # get only the wanted values and create a new dictionary from it
            element = {
                "Id": element['id'],
                "Modified": element['Modified'],
                "Published": element['Published'],
                "Assigner": element['assigner'],
                "References": str('\n'.join(element['references'])),
                "Summary": element['summary']
            }
            
            # create a readable line from each key:value pair
            # add line to post separated by newline
            for key in list(element.keys()):

                value = str(element[key])
                readable_text += f'{str(key)}: {value}\n'
            
            readable_text+='\n\n'
        
        # add credits cus were not mean
        readable_text+="\n\nInformation provided by CVE Search public API -> https://www.circl.lu/services/cve-search/"
        
        return readable_text
            
    # reads a JSON-formatted file and returns a dictionary
    def read_json(self, file_path):
        try:
            f = open(file_path, 'r')
            content = f.read()
            f.close()
            return json.loads(content)
        except Exception as e:
            print(e)
            return {}
    
    # writes a dictionary to a JSON-formatted file
    # returns false if failed
    def write_json(self, file_path, dictionary):
        try:
            f = open(file_path, 'w')
            f.write(json.dumps(dictionary, indent=2))
            f.close()

            return True
        except Exception as e:
            print(e)

            return False
    
    # gets categories from Discourse API
    # if no args are specified, you will get all data
    # if args are specified, it will return the value for reach key (args) you add
    # Example: get_categories('name'. 'id') -> {'name':'val','id':'val'}
    def get_categories(self, *filters):
        # gets categories from Discourse API (dictionary)
        categories = self.client.categories()
        filtered_results = []

        # if there are no filters supplied, return the raw categories output
        if len(filters) == 0:
            return categories
        
        # if filters are applied, get them and return them
        for category in categories:
            new_category = {}
            for filter in filters:
                # only do something if the filter is a key
                # if a bad key is passed it will be ignored
                if str(filter) in list(category.keys()):
                    # add the new key along with its value to the filtered result
                    new_category[str(filter)] = category[filter]
                
            filtered_results.append(new_category)
        
        return filtered_results
    
    # implicitly gets categories from API and returns the ID for a given category if exists
    # if category does not exist, will return -1
    def category_id_from_name(self, category_name):
        data = self.get_categories('name', 'id')

        # returns -1 if not found
        ctg_id = -1

        for ctg in data:
            # if the category name supplied was found in categories returned from API
            if ctg['name'] == category_name.strip():
                # get the id of the category and break
                ctg_id = ctg['id']
                break
        
        return ctg_id
    
    # created a post on the forum. Must be properly formatted, returns nothing.
    def create_post(self, title, content, category_name):
        # API requires a category ID to be supplied.
        # This function makes it easy to pass the name instead 
        category_id = self.category_id_from_name(category_name)
        
        # Print while posting so we know if it freezes
        print(f'Posting: {title}...')
        self.client.create_post(content=content, category_id=str(category_id), topic_id=None, title=title)
        print(f'Posted!')
    
    
    
    def cve_daemon(self, top_daily=30):

        api = CVEScout()

        # make sure top daily is an interger
        # and kick the bucket sooner :x
        try:
            top_daily = int(top_daily)
        except:
            print(f'Recent post count top_daily must be an interger!\n\tYou put: {top_daily}')
            exit()

        while True:

            today = timestamp()
            todays_cves = []
            returned_yesterday = 0

            print(f'Getting {top_daily} recent CVEs...', end='', flush=True)
            recent_cve = api.get_recent(top_daily)
            print(f' Done. ')

            # check if there is a previous save
            if not os.path.isfile(f'.recent'):

                # if there was none, post the top 10 recent
                todays_cves = recent_cve[:9]
                
                # save todays query
                self.write_json('.recent', recent_cve)

            # this will run second time and on
            else:
                # load the history
                last_query = self.read_json('.recent')

                # for each of the new CVEs, append all ones not recorded yesterday
                # to a list todays_cves.
                for cve in recent_cve:

                    if cve not in last_query:
                        todays_cves.append(cve)
                    else:
                        # keep count of how many were old for stats
                        returned_yesterday += 1

                print(f'Already posted {returned_yesterday} of the {len(recent_cve)} CVEs found today.')

            # apply formatting rules to todays CVE list
            post_content = self.readable(todays_cves)
            print(post_content)
                
            # post todays cves
            self.create_post(
                title=f'CVE List for {today} - {len(todays_cves)} Latest Vulnerabilities',
                content=post_content,
                category_name="Vulnerability"
            )

            print(f'Sleeping...')
            time.sleep(86400)
