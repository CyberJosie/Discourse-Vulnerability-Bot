
import os
import json
import time
from datetime import datetime
from pydiscourse import DiscourseClient

from cvebot.Logger import Logger
from cvebot.CVEScout import CVEScout
from cvebot.Timer import Timer
from cvebot.Configuration import Configuration

HOUR = 3600
DAY = HOUR*24

cfg = Configuration()
config = cfg.load(
    auto_dump=True,
    verbose=True
)

TIME_TO_RUN = config['bot']['run-time']

def timestamp():
    now = datetime.now()
    return now.strftime('%Y-%m-%d')

# Uses dicourse API wrapper pydiscourse and CVE sources
# to post CVEs on discourse daily
class DiscourseCVEBot:

    def __init__(self):
        # load API auth from config
        self.url = str(config['discourse']['url'])
        self.user = str(config['discourse']['username'])
        self.api_key = str(config['discourse']['token'])
        self.post_category = str(config['discourse']['category'])

        self.client = DiscourseClient(
            self.url,
            api_username = self.user,
            api_key = self.api_key
        )
    

    # creates a readable paragraph from a dictionary
    # this function will take in CVE dictionary from database API
    # and return a string format with filtered results suitible for blog post
    # append all post formatting changed here!
    # 
    # ARGS: Can be passed a single cve or list of cves.
    def readable(self, elements):
        readable_text = ''
        
        # allowed for a list or dict
        elements = list(elements)

        for element in elements:
            # get only the wanted values and create a new dictionary from it
            element = {
                "Id": element['id'],
                "Modified": element['Modified'],
                "Published": element['Published'],
                "Assigner": element['assigner'],
                "References": str('\n'.join(element['references'])),
                "Summary": element['summary']
            }
            
            # create a readable line from each key:value pair
            # add line to post separated by newline
            for key in list(element.keys()):

                value = str(element[key])
                readable_text += f'{str(key)}: {value}\n'
            
            readable_text+='\n\n'
        
        # add credits cus were not mean
        readable_text+="\n\nInformation provided by CVE Search public API -> https://www.circl.lu/services/cve-search/"
        
        return readable_text
            
    # reads a JSON-formatted file and returns a dictionary
    def read_json(self, file_path, verbose=False):
        log = Logger()
        try:
            f = open(file_path, 'r')
            content = f.read()
            f.close()
            return json.loads(content)
        except Exception as e:
            if verbose:
                print(str(e))
            
            log.commit(str(e), 'runtime')
            return {}
    
    # writes a dictionary to a JSON-formatted file
    # returns false if failed
    def write_json(self, file_path, dictionary, verbose=False):
        log = Logger()
        try:
            f = open(file_path, 'w')
            f.write(json.dumps(dictionary, indent=2))
            f.close()

            return True
        except Exception as e:
            if verbose:
                print(str(e))
            
            log.commit(str(e), 'runtime')
            return False
    
    # gets categories from Discourse API
    # if no args are specified, you will get all data
    # if args are specified, it will return the value for reach key (args) you add
    # Example: get_categories('name'. 'id') -> {'name':'val','id':'val'}
    def get_categories(self, *filters):
        # gets categories from Discourse API (dictionary)
        categories = self.client.categories()
        filtered_results = []

        # if there are no filters supplied, return the raw categories output
        if len(filters) == 0:
            return categories
        
        # if filters are applied, get them and return them
        for category in categories:
            new_category = {}
            for filter in filters:
                # only do something if the filter is a key
                # if a bad key is passed it will be ignored
                if str(filter) in list(category.keys()):
                    # add the new key along with its value to the filtered result
                    new_category[str(filter)] = category[filter]
                
            filtered_results.append(new_category)
        
        return filtered_results
    
    # implicitly gets categories from API and returns the ID for a given category if exists
    # if category does not exist, will return -1
    def category_id_from_name(self, category_name):
        data = self.get_categories('name', 'id')

        # returns -1 if not found
        ctg_id = -1

        for ctg in data:
            # if the category name supplied was found in categories returned from API
            if ctg['name'] == category_name.strip():
                # get the id of the category and break
                ctg_id = ctg['id']
                break
        
        return ctg_id
    
    # created a post on the forum. Must be properly formatted, returns nothing.
    def create_post(self, title, content, category_name, verbose=True):
        log = Logger()
        # API requires a category ID to be supplied.
        # This function makes it easy to pass the name instead 
        category_id = self.category_id_from_name(category_name)
        
        # Print while posting so we know if it freezes
        if verbose:
            print(f'Posting: {title}...')
        
        self.client.create_post(content=content, category_id=str(category_id), topic_id=None, title=title)

        if verbose:
            print(f'Posted!')
        
        log.commit(f'Successfully created new post. [ characters={len(content)} | category={category_name}:{str(category_id)} ]', 'runtime')
    
    
    def cve_daemon(self, top_daily=30, verbose=True):

        api = CVEScout()
        log = Logger()

        # make sure top daily is an interger
        # and kick the bucket sooner :x
        try:
            top_daily = int(top_daily)
        except:
            err = f'Recent post count top_daily must be an interger!\n\tYou put: {top_daily}'
            if verbose:
                print(err)
            log.commit(err, 'runtime')
            exit()

        while True:

            today = timestamp()
            print(f"\n--<=( CVE Bot )=>--\n Date: {today}")

            # this will be filled with CVEs to post current day
            todays_cves = []
            # count of CVEs posted yesterday
            returned_yesterday = 0

            print(f'Getting {top_daily} recent CVEs...', end='', flush=True)
            recent_cves = api.get_recent(top_daily)
            print(f' Done. ')

            log.commit(f'Pulled {len(recent_cves)} CVEs from API', 'runtime')

            # check if there is a previous save
            if not os.path.isfile(f'.recent'):

                log.commit(f'No previous query found locally. Posting all content', 'runtime')

                # if there was none, post the top 10 recent
                todays_cves = recent_cves[:9]
                
                # save todays query
                self.write_json('.recent', recent_cves)

            # this will run second time and on
            else:
                # load the history
                last_query = self.read_json('.recent')

                log.commit(f'Found {len(last_query)} previous queries posted yesterday', 'runtime')

                # for each of the new CVEs, append all ones not recorded yesterday
                # to a list todays_cves.
                for cve in recent_cves:
                    
                    
                    if cve not in list(last_query):
                        todays_cves.append(cve)
                    else:
                        # keep count of how many were old for stats
                        returned_yesterday += 1

                info_msg = f'Got {len(recent_cves)} from remote database today\n\t{returned_yesterday} were posted yesterday.\n\t{len(todays_cves)} are being posted today.'
                log.commit(info_msg, 'runtime')
            

            if todays_cves == []:
                log.commit('No new CVEs found today.', 'runtime')
            else:

                # apply formatting rules to todays CVE list
                post_content = self.readable(todays_cves)
                

                # print("Fake posting for testing purposes...")

                # post todays cves
                self.create_post(
                    title=f'CVE List for {today} - {len(todays_cves)} Latest Vulnerabilities',
                    content=post_content,
                    category_name=self.post_category
                )

            # todays timer
            app_timer = Timer()

            # get todays date
            todays_date = app_timer.timestamp()
            todays_date_unix = app_timer.date_to_unix(todays_date)

            # add a day of seconds to todays timestamp
            # create tomorrows date
            day_from_now = app_timer.unix_to_date(todays_date_unix+DAY).split(' ')[0].strip()
            tmrw_date = f'{day_from_now} {TIME_TO_RUN}'

            info_msg = f'Waiting until {tmrw_date}...'

            if verbose:
                print(info_msg)            
            log.commit(info_msg, 'runtime')

            # start timer
            app_timer.set(tmrw_date)

            # pause daily loop until timer has finished

            while True:
                if app_timer.finished:
                    break
