import time
import math
import threading
from datetime import datetime


"""
This timer take in any future date and dies when it is reached

Use Timer.is_alive() to check if it's still couting down to date

Date format:  YYYY-MM-DD HH:MM:SS
Date Example: 2022-04-20 16:20:00
                   ^   
                April 20, 2022 @ 4:20 PM
"""

class Timer:

    def __init__(self):
        self.finish_date = None
        self.finished = False
    
    def set(self, finish_date):
        self.finish_date = finish_date
        timer_thread = threading.Thread(target=self._sleep_until_date)
        timer_thread.daemon = True
        timer_thread.start()
        print(f'Started timer. Finish: {self.finish_date}')

    # takes datetime arguments and returns a unix timestamp
    def to_unix(self, year, month, day, hour, minute, second):
        date = datetime(year=year, month=month, day=day, hour=hour, minute=minute, second=second)
        return time.mktime(date.timetuple())
    
    def unix_to_date(self, unix_time):
        dt_obj = datetime.fromtimestamp(int(unix_time))
        return (dt_obj.strftime('%Y-%m-%d %H:%M:%S'))

    # returns formatted timestamp (full date and time)
    def timestamp(self):
        now = datetime.now()
        return str(now.strftime('%Y-%m-%d %H:%M:%S'))
    
    
    # YYYY-MM-DD HH:MM:SS
    # takes in a date time string formateed as expected
    # returns a UNIX timestamp
    def date_to_unix(self, date_string):
        measures = date_string.split(' ')
        date = measures[0]
        time_of_day = measures[1]

        parts = date.split('-')
        tod_parts = time_of_day.split(':')


        return self.to_unix(
            year=int(parts[0]),
            month=int(parts[1]),
            day=int(parts[2]),

            hour=int(tod_parts[0]),
            minute=int(tod_parts[1]),
            second=int(tod_parts[2])
        )
    
    # returns finished negated
    # finished is only true when the date is reached
    def is_alive(self):
        return not self.finished
    
    # this thread runs until date
    def _sleep_until_date(self):

        # convert today and finish date to unix epoch
        date_today = self.timestamp()

        today_unix = self.date_to_unix(date_today)
        finish_unix = self.date_to_unix(self.finish_date)

        # get the seconds count between two times
        seconds_difference = math.floor(int(finish_unix)) - math.floor(int(today_unix))

        # return now if the date given was in past
        if seconds_difference < 1:
            print('That time has passed!')
            return

        # sleep that amount of seconds
        time.sleep(seconds_difference)
        self.finished = True
